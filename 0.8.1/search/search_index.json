{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ng-log","text":"<p>ng-log (formerly Google Logging Library or glog) is a C++14 library that implements application-level logging. The library provides logging APIs based on C++-style streams and various helper macros.</p> <p>Compatibility to glog</p> <p>To avoid trademark issues, ng-log introduces a new set of functions derived from their glog counterparts. During a grace period, ng-log will maintain API compatibility to glog up to version 0.9.0 of the library. We therefore recommend updating the API as soon possible as the compatibility layer will be eventually removed.</p>"},{"location":"#how-to-use","title":"How to Use","text":"<p>You can log a message by simply streaming things to <code>LOG</code>(&lt;a particular severity level&gt;), e.g.,</p> main.cpp<pre><code>#include &lt;ng-log/logging.h&gt;\n\nint main(int argc, char* argv[]) {\n    nglog::InitializeLogging(argv[0]); // (1)!\n    LOG(INFO) &lt;&lt; \"Found \" &lt;&lt; num_cookies &lt;&lt; \" cookies\"; // (2)!\n}\n</code></pre> <ol> <li>Initialize library</li> <li>Log a message with informational severity</li> </ol> <p>The library can be installed using various package managers or compiled from source. For a detailed overview of ng-log features and their usage, please refer to the user guide.</p> <p>Warning</p> <p>The above example requires further Bazel or CMake setup for use in own projects.</p>"},{"location":"build/","title":"Building from Source","text":""},{"location":"build/#bazel","title":"Bazel","text":"<p>To use ng-log within a project which uses the Bazel build tool, add the following lines to your <code>MODULE.bazel</code> file:</p> MODULE.bazel<pre><code>bazel_dep(name = \"gflags\", version = \"2.2.2\")\nbazel_dep(name = \"ng-log\", version = \"0.8.1\")\n</code></pre> <p>You can then add <code>@ng-log//:ng-log</code> to the deps section of a <code>cc_binary</code> or <code>cc_library</code> rule, and <code>#include &lt;ng-log/logging.h&gt;</code> to include it in your source code.</p> <p>Using ng-log in a Bazel project</p> <pre><code>cc_binary(\n    name = \"main\",\n    srcs = [\"main.cc\"],\n    deps = [\"@ng-log//:ng-log\"],\n)\n</code></pre>"},{"location":"build/#migrating-from-googleglog","title":"Migrating from google/glog","text":"<p>The Bazel target doesn't include the glog compatibility layer, so you'll need to adjust your code as follows:</p> <ul> <li>replace <code>&lt;glog/logging.h&gt;</code> with <code>&lt;ng-log/logging.h&gt;</code> and similarly for other heads (flags, log_severity, stl_logging, etc)</li> <li>replace the <code>google::</code> namespace with <code>nglog::</code></li> <li>replace <code>InitGoogleLogging</code> with <code>InitializeLogging</code></li> <li>replace <code>IsGoogleLoggingInitialized</code> with <code>IsLoggingInitialized</code></li> <li>replace <code>ShutdownGoogleLogging</code> with <code>ShutdownLogging</code></li> </ul>"},{"location":"build/#cmake","title":"CMake","text":"<p>ng-log can be compiled using CMake on a wide range of platforms. The typical workflow for building ng-log on a Unix-like system with GNU Make as build tool is as follows:</p> <ol> <li>Clone the repository and change into source directory.   <pre><code>git clone https://github.com/ng-log/ng-log.git\ncd ng-log\n</code></pre></li> <li>Run CMake to configure the build tree.   <pre><code>cmake -S . -B build -G \"Unix Makefiles\"\n</code></pre>   CMake provides different generators, and by default will pick the most   relevant one to your environment. If you need a specific version of Visual   Studio, use <code>cmake . -G &lt;generator-name&gt;</code>, and see <code>cmake --help</code> for the available generators. Also see <code>-T &lt;toolset-name&gt;</code>, which can   be used to request the native x64 toolchain with <code>-T host=x64</code>.</li> <li>Afterwards, generated files can be used to compile the project.   <pre><code>cmake --build build\n</code></pre></li> <li>Test the build software (optional).   <pre><code>cmake --build build --target test\n</code></pre></li> <li>Install the built files (optional).   <pre><code>cmake --build build --target install\n</code></pre></li> </ol> <p>Once successfully built, ng-log can be integrated into own projects.</p>"},{"location":"contribute/","title":"How to Contribute","text":"<p>We'd love to accept your patches and contributions to this project. There are a just a few small guidelines you need to follow.</p>"},{"location":"contribute/#submitting-a-patch","title":"Submitting a Patch","text":"<ol> <li>It's generally best to start by opening a new issue describing the     bug or feature you're intending to fix. Even if you think it's     relatively minor, it's helpful to know what people are working on.     Mention in the initial issue that you are planning to work on that     bug or feature so that it can be assigned to you.</li> <li>Follow the normal process of     forking the project,     and setup a new branch to work in. It's important that each group of     changes be done in separate branches in order to ensure that a pull     request only includes the commits related to that bug or feature.</li> <li>Do your best to have well-formed commit     messages     for each change. This provides consistency throughout the project,     and ensures that commit messages are able to be formatted properly     by various git tools.</li> <li>Finally, push the commits to your fork and submit a pull     request.</li> </ol>"},{"location":"failures/","title":"Failure Signal Handler","text":""},{"location":"failures/#stacktrace-as-default-failure-handler","title":"Stacktrace as Default Failure Handler","text":"<p>The library provides a convenient signal handler that will dump useful information when the program crashes on certain signals such as <code>SIGSEGV</code>. The signal handler can be installed by <code>nglog::InstallFailureSignalHandler()</code>. The following is an example of output from the signal handler.</p> <pre><code>*** Aborted at 1225095260 (unix time) try \"date -d @1225095260\" if you are using GNU date ***\n*** SIGSEGV (@0x0) received by PID 17711 (TID 0x7f893090a6f0) from PID 0; stack trace: ***\nPC: @           0x412eb1 TestWaitingLogSink::send()\n    @     0x7f892fb417d0 (unknown)\n    @           0x412eb1 TestWaitingLogSink::send()\n    @     0x7f89304f7f06 nglog::LogMessage::SendToLog()\n    @     0x7f89304f35af nglog::LogMessage::Flush()\n    @     0x7f89304f3739 nglog::LogMessage::~LogMessage()\n    @           0x408cf4 TestLogSinkWaitTillSent()\n    @           0x4115de main\n    @     0x7f892f7ef1c4 (unknown)\n    @           0x4046f9 (unknown)\n</code></pre>"},{"location":"failures/#customizing-handler-output","title":"Customizing Handler Output","text":"<p>By default, the signal handler writes the failure dump to the standard error. However, it is possible to customize the destination by installing a callback using the <code>nglog::InstallFailureWriter()</code> function. The function expects a pointer to a function with the following signature:</p> <pre><code>void YourFailureWriter(const char* message/* (1)! */, std::size_t length/* (2)! */);\n</code></pre> <ol> <li> <p>The pointer references the start of the failure message.</p> <p>Danger</p> <p>The string is not null-terminated.</p> </li> <li> <p>The message length in characters.</p> </li> </ol> <p>Possible overflow errors</p> <p>Users should not expect the <code>message</code> string to be null-terminated.</p>"},{"location":"failures/#user-defined-failure-function","title":"User-defined Failure Function","text":"<p><code>FATAL</code> severity level messages or unsatisfied <code>CHECK</code> condition terminate your program. You can change the behavior of the termination by <code>nglog::InstallFailureFunction</code>.</p> <pre><code>void YourFailureFunction() {\n  // Reports something...\n  exit(EXIT_FAILURE);\n}\n\nint main(int argc, char* argv[]) {\n  nglog::InstallFailureFunction(&amp;YourFailureFunction);\n}\n</code></pre> <p>By default, ng-log tries to dump the stacktrace and calls <code>std::abort</code>. The stacktrace is generated only when running the application on a system supported<sup>1</sup> by ng-log.</p> <ol> <li> <p>To extract the stack trace, ng-log currently supports the following targets:</p> <ul> <li>x86, x86_64,</li> <li>PowerPC architectures,</li> <li><code>libunwind</code>,</li> <li>and the Debug Help Library (<code>dbghelp</code>) on Windows.</li> </ul> <p>\u21a9</p> </li> </ol>"},{"location":"flags/","title":"Adjusting Output","text":"<p>Several flags influence ng-log's output behavior.</p>"},{"location":"flags/#using-command-line-parameters-and-environment-variables","title":"Using Command-line Parameters and Environment Variables","text":"<p>If the Google gflags library is installed on your machine, the build system will automatically detect and use it, allowing you to pass flags on the command line.</p> <p>Activate <code>--logtostderr</code> in an application from the command line</p> <p>A binary <code>you_application</code> that uses ng-log can be started using <pre><code>./your_application --logtostderr=1\n</code></pre> to log to <code>stderr</code> instead of writing the output to a log file.</p> <p>Tip</p> <p>You can set boolean flags to <code>true</code> by specifying <code>1</code>, <code>true</code>, or <code>yes</code>. To set boolean flags to <code>false</code>, specify <code>0</code>, <code>false</code>, or <code>no</code>. In either case the spelling is case-insensitive.</p> <p>If the Google gflags library isn't installed, you set flags via environment variables, prefixing the flag name with <code>NGLOG_</code>, e.g.,</p> <p>Activate <code>logtostderr</code> without gflags</p> <pre><code>NGLOG_logtostderr=1 ./your_application\n</code></pre> <p>The following flags are most commonly used:</p> <code>logtostderr</code> (<code>bool</code>, default=<code>false</code>) <p>Log messages to <code>stderr</code> instead of logfiles.</p> <code>stderrthreshold</code> (<code>int</code>, default=2, which is <code>ERROR</code>) <p>Copy log messages at or above this level to <code>stderr</code> in addition to logfiles. The numbers of severity levels <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, and <code>FATAL</code> are 0, 1, 2, and 3, respectively.</p> <code>minloglevel</code> (<code>int</code>, default=0, which is <code>INFO</code>) <p>Log messages at or above this level. Again, the numbers of severity levels <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, and <code>FATAL</code> are 0, 1, 2, and 3, respectively.</p> <code>log_dir</code> (<code>string</code>, default=\"\") <p>If specified, logfiles are written into this directory instead of the default logging directory.</p> <code>v</code> (<code>int</code>, default=0) <p>Show all <code>VLOG(m)</code> messages for <code>m</code> less or equal the value of this flag. Overridable by <code>--vmodule</code>. Refer to verbose logging for more detail.</p> <code>vmodule</code> (<code>string</code>, default=\"\") <p>Per-module verbose level. The argument has to contain a comma-separated list of <code>&lt;module name&gt;=&lt;log level&gt;</code>. <code>&lt;module name&gt;</code> is a glob pattern (e.g., <code>gfs*</code> for all modules whose name starts with \"gfs\"), matched against the filename base (that is, name ignoring .cc/.h./-inl.h). <code>&lt;log level&gt;</code> overrides any value given by <code>--v</code>. See also verbose logging for more details.</p> <p>Additional flags are defined in flags.cc. Please see the source for their complete list.</p>"},{"location":"flags/#modifying-flags-programmatically","title":"Modifying Flags Programmatically","text":"<p>You can also modify flag values in your program by modifying global variables <code>FLAGS_*</code>. Most settings start working immediately after you update <code>FLAGS_*</code>. The exceptions are the flags related to destination files. For instance, you might want to set <code>FLAGS_log_dir</code> before calling <code>nglog::InitializeLogging</code>.</p> <p>Setting <code>log_dir</code> at runtime</p> <pre><code>LOG(INFO) &lt;&lt; \"file\";\n// Most flags work immediately after updating values.\nFLAGS_logtostderr = 1;\nLOG(INFO) &lt;&lt; \"stderr\";\nFLAGS_logtostderr = 0;\n// This won\u2019t change the log destination. If you want to set this\n// value, you should do this before nglog::InitializeLogging .\nFLAGS_log_dir = \"/some/log/directory\";\nLOG(INFO) &lt;&lt; \"the same file\";\n</code></pre>"},{"location":"license/","title":"The 3-Clause BSD License","text":"<p>Copyright \u00a9 2024, Google Inc. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li>Redistributions of source code must retain the above copyright notice, this   list of conditions and the following disclaimer.</li> <li>Redistributions in binary form must reproduce the above copyright notice, this   list of conditions and the following disclaimer in the documentation and/or   other materials provided with the distribution.</li> <li>Neither the name of Google Inc. nor the names of its contributors may be used   to endorse or promote products derived from this software without specific   prior written permission.</li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"log_cleaner/","title":"Automatically Remove Old Logs","text":"<p>To enable the log cleaner:</p> <pre><code>using namespace std::chrono_literals;\nnglog::EnableLogCleaner(24h * 3); // keep your logs for 3 days\n</code></pre> <p>In C++20 (and later) this can be shortened to:</p> <pre><code>using namespace std::chrono_literals;\nnglog::EnableLogCleaner(3d); // keep your logs for 3 days\n</code></pre> <p>And then ng-log will check if there are overdue logs whenever a flush is performed. In this example, any log file from your project whose last modified time is greater than 3 days will be <code>unlink</code>()ed.</p> <p>This feature can be disabled at any time (if it has been enabled) using <pre><code>nglog::DisableLogCleaner();\n</code></pre></p>"},{"location":"log_stripping/","title":"Strip Logging Messages","text":"<p>Strings used in log messages can increase the size of your binary and present a privacy concern. You can therefore instruct ng-log to remove all strings which fall below a certain severity level by using the <code>NGLOG_STRIP_LOG</code> macro:</p> <p>If your application has code like this:</p> <pre><code>#define NGLOG_STRIP_LOG 1    // this must go before the #include!\n#include &lt;ng-log/logging.h&gt;\n</code></pre> <p>The compiler will remove the log messages whose severities are less than the specified integer value. Since <code>VLOG</code> logs at the severity level <code>INFO</code> (numeric value <code>0</code>), setting <code>NGLOG_STRIP_LOG</code> to 1 or greater removes all log messages associated with <code>VLOG</code>s as well as <code>INFO</code> log statements.</p>"},{"location":"logging/","title":"Logging","text":"<p>ng-log defines a series of macros that simplify many common logging tasks. You can log messages by severity level, control logging behavior from the command line, log based on conditionals, abort the program when expected conditions are not met, introduce your own logging levels, customize the prefix attached to log messages, and more.</p>"},{"location":"logging/#severity-levels","title":"Severity Levels","text":"<p>You can specify one of the following severity levels (in increasing order of severity):</p> <ol> <li><code>INFO</code>,</li> <li><code>WARNING</code>,</li> <li><code>ERROR</code>, and</li> <li><code>FATAL</code>.</li> </ol> <p>Logging a <code>FATAL</code> message terminates the program (after the message is logged).</p> <p>Note</p> <p>Messages of a given severity are logged not only to corresponding severity logfile but also to other logfiles of lower severity. For instance, a message of severity <code>FATAL</code> will be logged to logfiles of severity <code>FATAL</code>, <code>ERROR</code>, <code>WARNING</code>, and <code>INFO</code>.</p> <p>The <code>DFATAL</code> severity logs a <code>FATAL</code> error in debug mode (i.e., there is no <code>NDEBUG</code> macro defined), but avoids halting the program in production by automatically reducing the severity to <code>ERROR</code>.</p>"},{"location":"logging/#log-files","title":"Log Files","text":"<p>Unless otherwise specified, ng-log uses the format</p> <pre><code>&lt;tmp&gt;/&lt;program name&gt;.&lt;hostname&gt;.&lt;user name&gt;.log.&lt;severity level&gt;.&lt;date&gt;-&lt;time&gt;.&lt;pid&gt;\n</code></pre> <p>for log filenames written to a directory designated as <code>&lt;tmp&gt;</code> and determined according to the following rules.</p> Windows <p>ng-log uses the GetTempPathA API function to retrieve the directory for temporary files with a fallback to</p> <ol> <li><code>C:\\TMP\\</code></li> <li><code>C:\\TEMP\\</code></li> </ol> <p>(in the order given.)</p> non-Windows <p>The directory is determined by referencing the environment variables</p> <ol> <li><code>TMPDIR</code></li> <li><code>TMP</code></li> </ol> <p>if set with a fallback to <code>/tmp/</code>.</p> <p>The default path to a log file on Linux, for instance, could be</p> <pre><code>/tmp/hello_world.example.com.hamaji.log.INFO.20080709-222411.10474\n</code></pre> <p>By default, ng-log echos <code>ERROR</code> and <code>FATAL</code> messages to standard error in addition to log files.</p>"},{"location":"logging/#log-line-prefix-format","title":"Log Line Prefix Format","text":"<p>Log lines have this form:</p> <pre><code>Lyyyymmdd hh:mm:ss.uuuuuu threadid file:line] msg...\n</code></pre> <p>where the fields are defined as follows:</p> Placeholder Meaning <code>L</code> A single character, representing the log level (e.g., <code>I</code> for <code>INFO</code>) <code>yyyy</code> The year <code>mm</code> The month (zero padded; i.e., May is <code>05</code>) <code>dd</code> The day (zero padded) <code>hh:mm:ss.uuuuuu</code> Time in hours, minutes and fractional seconds <code>threadid</code> The space-padded thread ID <code>file</code> The file name <code>line</code> The line number <code>msg</code> The user-supplied message <p>Default log line prefix format</p> <pre><code>I1103 11:57:31.739339 24395 nglog.cc:2341] Command line: ./some_prog\nI1103 11:57:31.739403 24395 nglog.cc:2342] Process id 24395\n</code></pre> <p>Note</p> <p>Although microseconds are useful for comparing events on a single machine, clocks on different machines may not be well synchronized. Hence, use with caution when comparing the low bits of timestamps from different machines.</p>"},{"location":"logging/#format-customization","title":"Format Customization","text":"<p>The predefined log line prefix can be replaced using a user-provided callback that formats the corresponding output.</p> <p>For each log entry, the callback will be invoked with a reference to a <code>nglog::LogMessage</code> instance containing the severity, filename, line number, thread ID, and time of the event. It will also be given a reference to the output stream, whose contents will be prepended to the actual message in the final log line.</p> <p>To enable the use of a prefix formatter, use the</p> <pre><code>nglog::InstallPrefixFormatter(&amp;MyPrefixFormatter);\n</code></pre> <p>function to pass a pointer to the corresponding <code>MyPrefixFormatter</code> callback during initialization. <code>InstallPrefixFormatter</code> takes a second optional argument of type <code>void*</code> that allows supplying user data to the callback.</p> <p>Custom prefix formatter</p> <p>The following function outputs a prefix that matches ng-log's default format. The third parameter <code>data</code> can be used to access user-supplied data which unless specified defaults to <code>nullptr</code>.</p> <pre><code>void MyPrefixFormatter(std::ostream&amp; s, const nglog::LogMessage&amp; m, void* /*data*/) {\n   s &lt;&lt; nglog::GetLogSeverityName(m.severity())[0]\n   &lt;&lt; setw(4) &lt;&lt; 1900 + m.time().year()\n   &lt;&lt; setw(2) &lt;&lt; 1 + m.time().month()\n   &lt;&lt; setw(2) &lt;&lt; m.time().day()\n   &lt;&lt; ' '\n   &lt;&lt; setw(2) &lt;&lt; m.time().hour() &lt;&lt; ':'\n   &lt;&lt; setw(2) &lt;&lt; m.time().min()  &lt;&lt; ':'\n   &lt;&lt; setw(2) &lt;&lt; m.time().sec() &lt;&lt; \".\"\n   &lt;&lt; setw(6) &lt;&lt; m.time().usec()\n   &lt;&lt; ' '\n   &lt;&lt; setfill(' ') &lt;&lt; setw(5)\n   &lt;&lt; m.thread_id() &lt;&lt; setfill('0')\n   &lt;&lt; ' '\n   &lt;&lt; m.basename() &lt;&lt; ':' &lt;&lt; m.line() &lt;&lt; \"]\";\n}\n</code></pre>"},{"location":"logging/#conditional-occasional-logging","title":"Conditional / Occasional Logging","text":"<p>Sometimes, you may only want to log a message under certain conditions. You can use the following macros to perform conditional logging:</p> <pre><code>LOG_IF(INFO, num_cookies &gt; 10) &lt;&lt; \"Got lots of cookies\";\n</code></pre> <p>The \"Got lots of cookies\" message is logged only when the variable <code>num_cookies</code> exceeds 10. If a line of code is executed many times, it may be useful to only log a message at certain intervals. This kind of logging is most useful for informational messages.</p> <pre><code>LOG_EVERY_N(INFO, 10) &lt;&lt; \"Got the \" &lt;&lt; nglog::COUNTER &lt;&lt; \"th cookie\";\n</code></pre> <p>The above line outputs a log messages on the 1st, 11th, 21st, ... times it is executed.</p> <p>Note</p> <p>The placeholder <code>nglog::COUNTER</code> identifies the recurring repetition.</p> <p>You can combine conditional and occasional logging with the following macro.</p> <pre><code>LOG_IF_EVERY_N(INFO, (size &gt; 1024), 10) &lt;&lt; \"Got the \" &lt;&lt; nglog::COUNTER\n                                        &lt;&lt; \"th big cookie\";\n</code></pre> <p>Instead of outputting a message every nth time, you can also limit the output to the first n occurrences:</p> <pre><code>LOG_FIRST_N(INFO, 20) &lt;&lt; \"Got the \" &lt;&lt; nglog::COUNTER &lt;&lt; \"th cookie\";\n</code></pre> <p>Outputs log messages for the first 20 times it is executed. The <code>nglog::COUNTER</code> identifier indicates which repetition is happening.</p> <p>Other times, it is desired to only log a message periodically based on a time. For instance, to log a message every 10ms:</p> <pre><code>LOG_EVERY_T(INFO, 0.01) &lt;&lt; \"Got a cookie\";\n</code></pre> <p>Or every 2.35s:</p> <pre><code>LOG_EVERY_T(INFO, 2.35) &lt;&lt; \"Got a cookie\";\n</code></pre>"},{"location":"logging/#verbose-logging","title":"Verbose Logging","text":"<p>When you are chasing difficult bugs, thorough log messages are very useful. However, you may want to ignore too verbose messages in usual development. For such verbose logging, ng-log provides the <code>VLOG</code> macro, which allows you to define your own numeric logging levels.</p> <p>The <code>--v</code> command line option controls which verbose messages are logged:</p> <pre><code>VLOG(1) &lt;&lt; \"I\u2019m printed when you run the program with --v=1 or higher\";\nVLOG(2) &lt;&lt; \"I\u2019m printed when you run the program with --v=2 or higher\";\n</code></pre> <p>With <code>VLOG</code>, the lower the verbose level, the more likely messages are to be logged. For example, if <code>--v==1</code>, <code>VLOG(1)</code> will log, but <code>VLOG(2)</code> will not log.</p> <p>Warning</p> <p>The <code>VLOG</code> behavior is opposite of the severity level logging, where <code>INFO</code>, <code>ERROR</code>, etc. are defined in increasing order and thus <code>--minloglevel</code> of 1 will only log <code>WARNING</code> and above.</p> <p>Though you can specify any integers for both <code>VLOG</code> macro and <code>--v</code> flag, the common values for them are small positive integers. For example, if you write <code>VLOG(0)</code>, you should specify <code>--v=-1</code> or lower to silence it. This is less useful since we may not want verbose logs by default in most cases. The <code>VLOG</code> macros always log at the <code>INFO</code> log level (when they log at all).</p> <p>Verbose logging can be controlled from the command line on a per-module basis:</p> <pre><code>--vmodule=mapreduce=2,file=1,gfs*=3 --v=0\n</code></pre> <p>Specifying these options will specifically:</p> <ol> <li>Print <code>VLOG(2)</code> and lower messages from mapreduce.{h,cc}</li> <li>Print <code>VLOG(1)</code> and lower messages from file.{h,cc}</li> <li>Print <code>VLOG(3)</code> and lower messages from files prefixed with \"gfs\"</li> <li>Print <code>VLOG(0)</code> and lower messages from elsewhere</li> </ol> <p>The wildcarding functionality 3. supports both <code>*</code> (matches 0 or more characters) and <code>?</code> (matches any single character) wildcards. Please also refer to command line flags for more information.</p> <p>There's also <code>VLOG_IS_ON(n)</code> \"verbose level\" condition macro. This macro returns <code>true</code> when the <code>--v</code> is equal to or greater than <code>n</code>. The macro can be used as follows:</p> <pre><code>if (VLOG_IS_ON(2)) {\n    // (1)\n}\n</code></pre> <ol> <li>Here we can perform some logging preparation and logging that can\u2019t be    accomplished with just <code>VLOG(2) &lt;&lt; \"message ...\";</code></li> </ol> <p>Verbose level condition macros <code>VLOG_IF</code>, <code>VLOG_EVERY_N</code> and <code>VLOG_IF_EVERY_N</code> behave analogous to <code>LOG_IF</code>, <code>LOG_EVERY_N</code>, <code>LOG_IF_EVERY_N</code>, but accept a numeric verbosity level as opposed to a severity level.</p> <pre><code>VLOG_IF(1, (size &gt; 1024))\n   &lt;&lt; \"I\u2019m printed when size is more than 1024 and when you run the \"\n      \"program with --v=1 or more\";\nVLOG_EVERY_N(1, 10)\n   &lt;&lt; \"I\u2019m printed every 10th occurrence, and when you run the program \"\n      \"with --v=1 or more. Present occurrence is \" &lt;&lt; nglog::COUNTER;\nVLOG_IF_EVERY_N(1, (size &gt; 1024), 10)\n   &lt;&lt; \"I\u2019m printed on every 10th occurrence of case when size is more \"\n      \" than 1024, when you run the program with --v=1 or more. \";\n      \"Present occurrence is \" &lt;&lt; nglog::COUNTER;\n</code></pre> <p>Performance</p> <p>The conditional logging macros provided by nglog (e.g., <code>CHECK</code>, <code>LOG_IF</code>, <code>VLOG</code>, etc.) are carefully implemented and don't execute the right hand side expressions when the conditions are false. So, the following check may not sacrifice the performance of your application.</p> <pre><code>CHECK(obj.ok) &lt;&lt; obj.CreatePrettyFormattedStringButVerySlow();\n</code></pre>"},{"location":"logging/#debugging-support","title":"Debugging Support","text":"<p>Special debug mode logging macros only have an effect in debug mode and are compiled away to nothing for non-debug mode compiles. Use these macros to avoid slowing down your production application due to excessive logging.</p> <pre><code>DLOG(INFO) &lt;&lt; \"Found cookies\";\nDLOG_IF(INFO, num_cookies &gt; 10) &lt;&lt; \"Got lots of cookies\";\nDLOG_EVERY_N(INFO, 10) &lt;&lt; \"Got the \" &lt;&lt; nglog::COUNTER &lt;&lt; \"th cookie\";\nDLOG_FIRST_N(INFO, 10) &lt;&lt; \"Got the \" &lt;&lt; nglog::COUNTER &lt;&lt; \"th cookie\";\nDLOG_EVERY_T(INFO, 0.01) &lt;&lt; \"Got a cookie\";\n</code></pre>"},{"location":"logging/#runtime-checks","title":"Runtime Checks","text":"<p>It is a good practice to check expected conditions in your program frequently to detect errors as early as possible. The <code>CHECK</code> macro provides the ability to abort the application when a condition is not met, similar to the <code>assert</code> macro defined in the standard C library.</p> <p><code>CHECK</code> aborts the application if a condition is not true. Unlike <code>assert</code>, it is not controlled by <code>NDEBUG</code>, so the check will be executed regardless of compilation mode. Therefore, <code>fp-&gt;Write(x)</code> in the following example is always executed:</p> <pre><code>CHECK(fp-&gt;Write(x) == 4) &lt;&lt; \"Write failed!\";\n</code></pre> <p>There are various helper macros for equality/inequality checks -<code>CHECK_EQ</code>, <code>CHECK_NE</code>, <code>CHECK_LE</code>, <code>CHECK_LT</code>, <code>CHECK_GE</code>, and <code>CHECK_GT</code>. They compare two values, and log a <code>FATAL</code> message including the two values when the result is not as expected. The values must have <code>operator&lt;&lt;(ostream, ...)</code> defined.</p> <p>You may append to the error message like so:</p> <pre><code>CHECK_NE(1, 2) &lt;&lt; \": The world must be ending!\";\n</code></pre> <p>We are very careful to ensure that each argument is evaluated exactly once, and that anything which is legal to pass as a function argument is legal here. In particular, the arguments may be temporary expressions which will end up being destroyed at the end of the apparent statement, for example:</p> <pre><code>CHECK_EQ(string(\"abc\")[1], \u2019b\u2019);\n</code></pre> <p>The compiler reports an error if one of the arguments is a pointer and the other is <code>nullptr</code>. To work around this, simply <code>static_cast</code> <code>nullptr</code> to the type of the desired pointer.</p> <pre><code>CHECK_EQ(some_ptr, static_cast&lt;SomeType*&gt;(nullptr));\n</code></pre> <p>Better yet, use the <code>CHECK_NOTNULL</code> macro:</p> <pre><code>CHECK_NOTNULL(some_ptr);\nsome_ptr-&gt;DoSomething();\n</code></pre> <p>Since this macro returns the given pointer, this is very useful in constructor initializer lists.</p> <pre><code>struct S {\n    S(Something* ptr) : ptr_(CHECK_NOTNULL(ptr)) {}\n    Something* ptr_;\n};\n</code></pre> <p>Warning</p> <p>Due to the argument forwarding, <code>CHECK_NOTNULL</code> cannot be used to simultaneously stream an additional custom message. To provide a custom message, one can use the macro <code>CHECK_EQ</code> prior to the failing check.</p> <p>If you are comparing C strings (<code>char *</code>), a handy set of macros performs both case sensitive and insensitive comparisons - <code>CHECK_STREQ</code>, <code>CHECK_STRNE</code>, <code>CHECK_STRCASEEQ</code>, and <code>CHECK_STRCASENE</code>. The <code>CHECK_*CASE*</code> macro variants are case-insensitive. You can safely pass <code>nullptr</code> pointers to this macro. They treat <code>nullptr</code> and any non-<code>nullptr</code> string as not equal. Two <code>nullptr</code>s are equal.</p> <p>Note</p> <p>Both arguments may be temporary objects which are destructed at the end of the current full expression, such as</p> <pre><code>CHECK_STREQ(Foo().c_str(), Bar().c_str());\n</code></pre> <p>where <code>Foo</code> and <code>Bar</code> return <code>std::string</code>.</p> <p>The <code>CHECK_DOUBLE_EQ</code> macro checks the equality of two floating point values, accepting a small error margin. <code>CHECK_NEAR</code> accepts a third floating point argument, which specifies the acceptable error margin.</p>"},{"location":"logging/#raw-logging","title":"Raw Logging","text":"<p>The header file <code>&lt;ng-log/raw_logging.h&gt;</code> can be used for thread-safe logging, which does not allocate any memory or acquire any locks. Therefore, the macros defined in this header file can be used by low-level memory allocation and synchronization code. Please check src/ng-log/raw_logging.h for detail.</p>"},{"location":"logging/#google-style-perror","title":"Google Style <code>perror()</code>","text":"<p><code>PLOG()</code> and <code>PLOG_IF()</code> and <code>PCHECK()</code> behave exactly like their <code>LOG*</code> and <code>CHECK</code> equivalents with the addition that they append a description of the current state of <code>errno</code> to their output lines. E.g.</p> <pre><code>PCHECK(write(1, nullptr, 2) &gt;= 0) &lt;&lt; \"Write nullptr failed\";\n</code></pre> <p>This check fails with the following error message.</p> <pre><code>F0825 185142 test.cc:22] Check failed: write(1, nullptr, 2) &gt;= 0 Write nullptr failed: Bad address [14]\n</code></pre>"},{"location":"logging/#syslog","title":"Syslog","text":"<p><code>SYSLOG</code>, <code>SYSLOG_IF</code>, and <code>SYSLOG_EVERY_N</code> macros are available. These log to syslog in addition to the normal logs. Be aware that logging to syslog can drastically impact performance, especially if syslog is configured for remote logging! Make sure you understand the implications of outputting to syslog before you use these macros. In general, it's wise to use these macros sparingly.</p>"},{"location":"packages/","title":"Installation using Package Managers","text":""},{"location":"packages/#conan","title":"conan","text":"<p>You can download and install ng-log using the conan package manager:</p> <pre><code>pip install conan\nconan install -r conancenter ng-log/&lt;ng-log-version&gt;@\n</code></pre> <p>The ng-log recipe in conan center is kept up to date by conan center index community contributors. If the version is out of date, please create an issue or pull request on the conan-center-index repository.</p>"},{"location":"packages/#vcpkg","title":"vcpkg","text":"<p>You can download and install ng-log using the vcpkg dependency manager:</p> <pre><code>git clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\n./vcpkg install ng-log\n</code></pre> <p>The ng-log port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please create an issue or pull request on the vcpkg repository.</p>"},{"location":"sinks/","title":"Custom Sinks","text":"<p>Under certain circumstances, it is useful to send the log output to a destination other than a file, <code>stderr</code> and/or <code>stdout</code>. For this purpose, the library provides the <code>nglog::LogSink</code> interface whose implementations can be used to write the log output to arbitrary locations.</p>"},{"location":"sinks/#basic-interface","title":"Basic Interface","text":"<p>The sink interface is defined as follows:</p> <pre><code>class LogSink {\n public:\n  virtual void send(LogSeverity severity, const char* full_filename,\n                    const char* base_filename, int line,\n                    const LogMessageTime&amp; time, const char* message,\n                    size_t message_len);\n};\n</code></pre> <p>The user must implement <code>nglog::LogSink::send</code>, which is called by the library every time a message is logged.</p> <p>Possible deadlock due to nested logging</p> <p>This method can't use <code>LOG()</code> or <code>CHECK()</code> as logging system mutex(s) are held during this call.</p>"},{"location":"sinks/#registering-log-sinks","title":"Registering Log Sinks","text":"<p>To use the custom sink and instance of the above interface implementation must be registered using <code>nglog::AddLogSink</code> which expects a pointer to the <code>nglog::LogSink</code> instance. To unregister use <code>nglog::RemoveLogSink</code>. Both functions are thread-safe.</p> <p><code>LogSink</code> ownership</p> <p>The <code>nglog::LogSink</code> instance must not be destroyed until the referencing pointer is unregistered.</p>"},{"location":"sinks/#direct-logging","title":"Direct Logging","text":"<p>Instead of registering the sink, we can directly use to log messages. While <code>LOG_TO_SINK(sink, severity)</code> allows to log both to the sink and to a global log registry, e.g., a file, <code>LOG_TO_SINK_BUT_NOT_TO_LOGFILE(sink, severity)</code> will avoid the latter.</p> <p>Using a custom sink</p> custom_sink.cc<pre><code>#include &lt;ng-log/logging.h&gt;\n\n#include &lt;algorithm&gt;\n#include &lt;cstddef&gt;\n#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\nnamespace {\n\nstruct MyLogSink : nglog::LogSink {  // (1)!\n  void send(nglog::LogSeverity severity, const char* /*full_filename*/,\n            const char* base_filename, int line,\n            const nglog::LogMessageTime&amp; /*time*/, const char* message,\n            std::size_t message_len) override {\n    std::cout &lt;&lt; nglog::GetLogSeverityName(severity) &lt;&lt; ' ' &lt;&lt; base_filename\n              &lt;&lt; ':' &lt;&lt; line &lt;&lt; ' ';\n    std::copy_n(message, message_len,\n                std::ostreambuf_iterator&lt;char&gt;{std::cout});\n    std::cout &lt;&lt; '\\n';\n  }\n};\n\n}  // namespace\n\nint main(int /*argc*/, char** argv) {\n  nglog::InitializeLogging(argv[0]);\n\n  MyLogSink sink;\n  nglog::AddLogSink(&amp;sink);  // (2)!\n\n  LOG(INFO) &lt;&lt; \"logging to MySink\";\n\n  nglog::RemoveLogSink(&amp;sink);  // (3)!\n\n  // We can directly log to a sink without registering it\n  LOG_TO_SINK(&amp;sink, INFO) &lt;&lt; \"direct logging\";  // (4)!\n  LOG_TO_SINK_BUT_NOT_TO_LOGFILE(&amp;sink, INFO)\n      &lt;&lt; \"direct logging but not to file\";\n}\n</code></pre> <ol> <li><code>MySink</code> implements a custom sink that sends log messages to <code>std::cout</code>.</li> <li>The custom sink must be registered to for use with existing logging    macros.</li> <li>Once the custom sink is no longer needed we remove it from the registry.</li> <li>A sink does not need to be registered globally. However, then, messages    must be logged using dedicated macros.</li> </ol> <p>Running the above example as <code>NGLOG_log_dir=. ./custom_sink_example</code> will produce</p> Custom sink output<pre><code>INFO custom_sink.cc:63 logging to MySink\nINFO custom_sink.cc:68 direct logging\nINFO custom_sink.cc:69 direct logging but not to file (1)\n</code></pre> <ol> <li>This line is not present in the log file because we used    <code>LOG_TO_SINK_BUT_NOT_TO_LOGFILE</code> to log the message.</li> </ol> <p>and the corresponding log file will contain</p> Log file generated with the custom sink<pre><code>Log file created at: 2024/06/11 13:24:27\nRunning on machine: pc\nRunning duration (h:mm:ss): 0:00:00\nLog line format: [IWEF]yyyymmdd hh:mm:ss.uuuuuu threadid file:line] msg\nI20240611 13:24:27.476620 126237946035776 custom_sink.cc:63] logging to MySink\nI20240611 13:24:27.476796 126237946035776 custom_sink.cc:68] direct logging\n</code></pre>"},{"location":"unwinder/","title":"Installation Notes for 64-bit Linux Systems","text":"<p>Note</p> <p>The description on this page is possibly not up-to-date.</p> <p>The glibc built-in stack-unwinder on 64-bit systems has some problems with ng-log. In particular, if you are using <code>InstallFailureSignalHandler()</code>, the signal may be raised in the middle of <code>malloc</code>, holding some <code>malloc</code>-related locks when they invoke the stack unwinder. The built-in stack unwinder may call <code>malloc</code> recursively, which may require the thread to acquire a lock it already holds resulting in a deadlock.</p>"},{"location":"unwinder/#recommended-approach-libunwind","title":"Recommended Approach: <code>libunwind</code>","text":"<p>For above reason, if you use a 64-bit system and you need <code>InstallFailureSignalHandler()</code>, we strongly recommend you install <code>libunwind</code> before trying to configure or install ng-log. libunwind can be found here.</p> <p>Even if you already have <code>libunwind</code> installed, you will probably still need to install from the snapshot to get the latest version.</p> <p>Warning</p> <p>If you install libunwind from the URL above, be aware that you may have trouble if you try to statically link your binary with ng-log: that is, if you link with <code>gcc -static -lgcc_eh ...</code>. This is because both <code>libunwind</code> and <code>libgcc</code> implement the same C++ exception handling APIs, but they implement them differently on some platforms. This is not likely to be a problem on ia64, but may be on x86-64.</p> <p>Also, if you link binaries statically, make sure that you add <code>-Wl,--eh-frame-hdr</code> to your linker options. This is required so that <code>libunwind</code> can find the information generated by the compiler required for stack unwinding.</p> <p>Using <code>-static</code> is rare, though, so unless you know this will affect you it probably won't.</p>"},{"location":"unwinder/#alternative-stack-unwinder","title":"Alternative Stack-unwinder","text":"<p>If you cannot or do not wish to install <code>libunwind</code>, you can still try to use two kinds of stack-unwinder:</p>"},{"location":"unwinder/#glibc-built-in-stack-unwinder","title":"glibc Built-in Stack-unwinder","text":"<p>As we already mentioned, glibc's unwinder has a deadlock issue. However, if you don't use <code>InstallFailureSignalHandler()</code> or you don't worry about the rare possibilities of deadlocks, you can use this stack-unwinder. If you specify no options and <code>libunwind</code> isn't detected on your system, the configure script chooses this unwinder by default.</p>"},{"location":"unwinder/#frame-pointer-based-stack-unwinder","title":"Frame Pointer based Stack-unwinder","text":"<p>The frame pointer based stack unwinder requires that your application, the ng-log library, and system libraries like libc, all be compiled with a frame pointer. This is not the default for x86-64.</p>"},{"location":"usage/","title":"Using ng-log in a CMake Project","text":"<p>Assuming that ng-log was previously built using CMake or installed using a package manager, you can use the CMake command <code>find_package</code> to build against ng-log in your CMake project as follows:</p> CMakeLists.txt<pre><code>cmake_minimum_required (VERSION 3.16)\nproject (myproj VERSION 1.0)\n\nfind_package (ng-log 0.8.1 REQUIRED)\n\nadd_executable (myapp main.cpp)\ntarget_link_libraries (myapp ng-log::ng-log)\n</code></pre> <p>Compile definitions and options will be added automatically to your target as needed.</p> <p>Alternatively, ng-log can be incorporated into using the CMake command <code>add_subdirectory</code> to include ng-log directly from a subdirectory of your project by replacing the <code>find_package</code> call from the previous snippet by <code>add_subdirectory</code>. The <code>ng-log::ng-log</code> target is in this case an <code>ALIAS</code> library target for the <code>ng-log</code> library target.</p>"},{"location":"windows/","title":"Notes for Windows Users","text":"<p>ng-log defines the severity level <code>ERROR</code>, which is also defined by <code>windows.h</code>. You can make nglog not define <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, and <code>FATAL</code> by defining <code>NGLOG_NO_ABBREVIATED_SEVERITIES</code> before including <code>nglog/logging.h</code>. Even with this macro, you can still use the iostream like logging facilities:</p> <pre><code>#define NGLOG_NO_ABBREVIATED_SEVERITIES\n#include &lt;windows.h&gt;\n#include &lt;ng-log/logging.h&gt;\n\n// ...\n\nLOG(ERROR) &lt;&lt; \"This should work\";\nLOG_IF(ERROR, x &gt; y) &lt;&lt; \"This should be also OK\";\n</code></pre> <p>However, you cannot use <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, and <code>FATAL</code> anymore for functions defined in <code>nglog/logging.h</code>.</p> <pre><code>#define NGLOG_NO_ABBREVIATED_SEVERITIES\n#include &lt;windows.h&gt;\n#include &lt;ng-log/logging.h&gt;\n\n// ...\n\n// This won\u2019t work.\n// nglog::FlushLogFiles(nglog::ERROR);\n\n// Use this instead.\nnglog::FlushLogFiles(nglog::NGLOG_ERROR);\n</code></pre> <p>If you don't need <code>ERROR</code> defined by <code>windows.h</code>, there are a couple of more workarounds which sometimes don't work<sup>1</sup>:</p> <ul> <li><code>#define WIN32_LEAN_AND_MEAN</code> or <code>NOGDI</code> before <code>#include &lt;windows.h&gt;</code>.</li> <li><code>#undef ERROR</code> after <code>#include &lt;windows.h&gt;</code>.</li> </ul> <ol> <li> <p>For more information refer to this   issue.\u00a0\u21a9</p> </li> </ol>"}]}